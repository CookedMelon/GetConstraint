I will give you an api description copy. Generate type constraints for each parameter and return value. 
The constraint needs to describe the dtype, dim, shape, struct, default value, and rank of the parameter.
Among them, the dtype needs to be selected from the following types, if there are restrictions on types, you need to list the supported types

 - float64  - tf.qint8  - tf.int64  - tf.float  - qint8  - tf.float32  - tf.qint16  - tf.bfloat16  - tf.complex128  - bool  - ints  - complex128  - float32  - tf.dtypes  - floats  - uint  - tf.uint64  - half  - quint16  - float16  - tf.uint8  - uint32  - tf.quint16  - tf.uint  - qint16  - double  - tf.boolean  - tf.dtype  - tf.int  - numeric  - tf.bool  - str  - quint8  - tf.int32  - float  - strings  - tf.half  - uint64  - string  - tf.str  - tf.complex  - boolean  - int64  - complex  - uint8  - tf.string  - bfloat16  - int8  - tf.uint16  - integer  - tf.float16  - floating  - tf.quint8  - tf.uint32  - int  - tf.qint32  - tf.complex64  - qint32  - int16  - complex64  - uint16  - tf.int16  - int32  - integers  - tf.float64  - tf.int8

the structure should be selected from the following types

  - list  - lists  - array  - arrays  - tuple  - dict  - dictionary  - iterable  - sequence  - ndarray  - array_like  - vector  - vectors  - tf.sparsetensor  - tf.tensor  - sparsetensor  - tensors  - tensor

You should also give each parameter's descp please notice that you only need to copy the description exactly as it is.
Parameters such as tensor shape can be represented by variables, using [] to represent a list of numbers and not using [] to represent a single number.
Use `` to indicate other input parameters of the api
When parameter constraints occur, the conditional branch can be expressed by the conditional expression '=>'
You should also explain which api parameters are required
Finally give me an yaml in this format
Add additional conditions under addition

You should get the extracted text is like this

```yaml
name: tf.nn.pool
dependency:
- batch_size
- num_channels
- [input_spatial_shape]
constraints:
  data_format:
    default: None
    descp: A string or None. Specifies whether the channel dimension of the `input` and output is the last dimension (default, or if `data_format` does not start with "NC"), or the second dimension (if `data_format` starts with "NC"). For N=1, the valid values are "NWC" (default) and "NCW". For N=2, the valid values are "NHWC" (default) and "NCHW". For N=3, the valid values are "NDHWC" (default) and "NCDHW".
    enum:
    - NWC
    - NCW
    - NHWC
    - NCHW
    - NDHWC
    - NCDHW
    dtype:
    - string
    addition:
    - ([input_spatial_shape.rank] ==1 ) => (`data_format` == NWC or `data_format` == NCW)
    - ([input_spatial_shape.rank] ==2 ) => (`data_format` == NHWC or `data_format` == NCHW)
    - ([input_spatial_shape.rank] ==3 ) => (`data_format` == NDHWC or `data_format` == NCDHW)


  dilations:
    default: None
    descp: Optional.  Dilation rate.  List of N ints >= 1. Defaults to [1]*N.  If
      any value of dilation_rate is > 1, then all values of strides must be 1.
    dtype:
    - int
    structure:
    - list
    addition:
    - `dilations.length` == [input_spatial_shape.rank]
  input:
    descp: Tensor of rank N+2, of shape `[batch_size] + input_spatial_shape + [num_channels]`
      if data_format does not start with "NC" (default), or`[batch_size, num_channels]
      + input_spatial_shape` if data_format starts with "NC".  Pooling happens over
      the spatial dimensions only.
    ndim:
    - [input_spatial_shape.rank] + 2
    shape:
    - (`data_format` != 'NC*') => (batch_size , [input_spatial_shape] , num_channels)
    - (`data_format` == 'NC*') => (batch_size , num_channels , [input_spatial_shape])
    structure:
    - tf.tensor
  name:
    default: None
    descp: Optional. Name of the op.
    dtype:
    - string
  padding:
    default: VALID
    descp: The padding algorithm, must be "SAME" or "VALID". Defaults to "SAME". See
      the "returns" section of `tf.nn.convolution` for details.
    enum:
    - SAME
    - VALID
    dtype:
    - string
  pooling_type:
    descp: Specifies pooling operation, must be "AVG" or "MAX".
    enum:
    - AVG
    - MAX
    dtype:
    - string

  strides:
    default: None
    descp: Optional. Sequence of N ints >= 1.  Defaults to [1]*N. If any value of
      strides is > 1, then all values of dilation_rate must be 1.
    dtype:
    - int
    structure:
    - list
    addition:
    - `strides.length` == [input_spatial_shape.rank]
    - `strides[i]` >= 1
  window_shape:
    descp: Sequence of N ints >= 1.
    dtype:
    - int
    structure:
    - list
    addition:
    - `window_shape.length` == [input_spatial_shape.rank]
    - `window_shape[i]` >= 1
returns:
  descp: Tensor of rank N+2, of shape [batch_size] + output_spatial_shape + [num_channels] if data_format is None or does not start with "NC", or [batch_size, num_channels] + output_spatial_shape if data_format starts with "NC", where output_spatial_shape depends on the value of padding If padding = "SAME" output_spatial_shape[i] = ceil(input_spatial_shape[i] / strides[i])"
  structure:
  - tf.tensor
  ndim:
  - [input_spatial_shape.rank] + 2
  shape:
  - batch_size , [input_spatial_shape] , num_channels

```

If you learned how to generate the yaml I want. Only tell me "yes" directly, then I will give you what api I want you to generate. After that, please generate yaml in the format above directly without any other instructions.